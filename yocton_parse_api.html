<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>yocton: Yocton Parse API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">yocton
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Yocton Parse API </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_parse_api"></a> This document is intended as an introductory guide to the Yocton parsing API. Let's start with a basic example that shows how to open an input file and read a single property:</p>
<div class="fragment"><div class="line">FILE *fs = fopen(filename, <span class="stringliteral">&quot;r&quot;</span>);</div>
<div class="line">assert(fs != NULL);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_typedef" href="yocton_8h.html#a2d8d989503af56c34319ace5532748b6">yocton_object</a> *obj = <a class="code hl_function" href="yocton_8h.html#a1c15d04cb8945c36d4dc16abbdd5b5f0">yocton_read_from</a>(fs);</div>
<div class="line">assert(obj != NULL);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_typedef" href="yocton_8h.html#aa1688438ce1435782795c9f2a0008807">yocton_prop</a> *p = <a class="code hl_function" href="yocton_8h.html#ac69750750bb48baa80600f3daf79447a">yocton_next_prop</a>(obj);</div>
<div class="line">assert(p != NULL);</div>
<div class="line"> </div>
<div class="line">printf(<span class="stringliteral">&quot;property %s has value %s\n&quot;</span>, <a class="code hl_function" href="yocton_8h.html#af58e01f89d1b2cacc998ee10c6422786">yocton_prop_name</a>(p),</div>
<div class="line">       <a class="code hl_function" href="yocton_8h.html#ae51150ada8b4ff73190a1c5c414ccf0e">yocton_prop_value</a>(p));</div>
<div class="ttc" id="ayocton_8h_html_a1c15d04cb8945c36d4dc16abbdd5b5f0"><div class="ttname"><a href="yocton_8h.html#a1c15d04cb8945c36d4dc16abbdd5b5f0">yocton_read_from</a></div><div class="ttdeci">struct yocton_object * yocton_read_from(FILE *fstream)</div><div class="ttdoc">Start reading a new stream of yocton-encoded data, using the given FILE handle to read more data.</div></div>
<div class="ttc" id="ayocton_8h_html_a2d8d989503af56c34319ace5532748b6"><div class="ttname"><a href="yocton_8h.html#a2d8d989503af56c34319ace5532748b6">yocton_object</a></div><div class="ttdeci">struct yocton_object yocton_object</div><div class="ttdoc">The object is the main abstraction of the Yocton format.</div><div class="ttdef"><b>Definition:</b> yocton.h:72</div></div>
<div class="ttc" id="ayocton_8h_html_aa1688438ce1435782795c9f2a0008807"><div class="ttname"><a href="yocton_8h.html#aa1688438ce1435782795c9f2a0008807">yocton_prop</a></div><div class="ttdeci">struct yocton_prop yocton_prop</div><div class="ttdoc">An object can have multiple properties.</div><div class="ttdef"><b>Definition:</b> yocton.h:81</div></div>
<div class="ttc" id="ayocton_8h_html_ac69750750bb48baa80600f3daf79447a"><div class="ttname"><a href="yocton_8h.html#ac69750750bb48baa80600f3daf79447a">yocton_next_prop</a></div><div class="ttdeci">struct yocton_prop * yocton_next_prop(struct yocton_object *obj)</div><div class="ttdoc">Read the next property of an object.</div></div>
<div class="ttc" id="ayocton_8h_html_ae51150ada8b4ff73190a1c5c414ccf0e"><div class="ttname"><a href="yocton_8h.html#ae51150ada8b4ff73190a1c5c414ccf0e">yocton_prop_value</a></div><div class="ttdeci">const char * yocton_prop_value(struct yocton_prop *property)</div><div class="ttdoc">Get the string value of a yocton_prop of type YOCTON_PROP_STRING.</div></div>
<div class="ttc" id="ayocton_8h_html_af58e01f89d1b2cacc998ee10c6422786"><div class="ttname"><a href="yocton_8h.html#af58e01f89d1b2cacc998ee10c6422786">yocton_prop_name</a></div><div class="ttdeci">const char * yocton_prop_name(struct yocton_prop *property)</div><div class="ttdoc">Get the name of a yocton_prop.</div></div>
</div><!-- fragment --><p >This example shows the basic boilerplate of how to get started with the API. A Yocton document is an object (<a class="el" href="yocton_8h.html#a2d8d989503af56c34319ace5532748b6">yocton_object</a>) which contains properties (<a class="el" href="yocton_8h.html#aa1688438ce1435782795c9f2a0008807">yocton_prop</a>). We can expand the example into one that prints every property in a file:</p>
<div class="fragment"><div class="line">FILE *fs = fopen(filename, <span class="stringliteral">&quot;r&quot;</span>);</div>
<div class="line">assert(fs != NULL);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_typedef" href="yocton_8h.html#a2d8d989503af56c34319ace5532748b6">yocton_object</a> *obj = <a class="code hl_function" href="yocton_8h.html#a1c15d04cb8945c36d4dc16abbdd5b5f0">yocton_read_from</a>(fs);</div>
<div class="line">assert(obj != NULL);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_typedef" href="yocton_8h.html#aa1688438ce1435782795c9f2a0008807">yocton_prop</a> *p;</div>
<div class="line"><span class="keywordflow">while</span> ((p = <a class="code hl_function" href="yocton_8h.html#ac69750750bb48baa80600f3daf79447a">yocton_next_prop</a>(obj)) != NULL) {</div>
<div class="line">  printf(<span class="stringliteral">&quot;property %s has value %s\n&quot;</span>, <a class="code hl_function" href="yocton_8h.html#af58e01f89d1b2cacc998ee10c6422786">yocton_prop_name</a>(p),</div>
<div class="line">         <a class="code hl_function" href="yocton_8h.html#ae51150ada8b4ff73190a1c5c414ccf0e">yocton_prop_value</a>(p));</div>
<div class="line">}</div>
</div><!-- fragment --><p >However, this example only works when all property values are strings. Property values may instead be objects; these can be accessed using <code><a class="el" href="yocton_8h.html#a25b051fc6bd8836d5f37c25cbac0f753" title="Get the inner object associated with a yocton_prop of type YOCTON_PROP_OBJECT.">yocton_prop_inner()</a></code>. Using this we can construct a recursive function that reads and prints all properties of all subobjects:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> print_obj(<span class="keyword">struct</span> <a class="code hl_typedef" href="yocton_8h.html#a2d8d989503af56c34319ace5532748b6">yocton_object</a> *obj) {</div>
<div class="line">  <span class="keyword">struct </span><a class="code hl_typedef" href="yocton_8h.html#aa1688438ce1435782795c9f2a0008807">yocton_prop</a> *p;</div>
<div class="line">  <span class="keywordflow">while</span> ((p = <a class="code hl_function" href="yocton_8h.html#ac69750750bb48baa80600f3daf79447a">yocton_next_prop</a>(obj)) != NULL) {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_enumeration" href="yocton_8h.html#ad4f38cb3e4a15df05cf64ebb0b18e763">yocton_prop_type</a>(p) == <a class="code hl_enumvalue" href="yocton_8h.html#ad4f38cb3e4a15df05cf64ebb0b18e763abbdd6efd548f5d6d02a6e7c9fdb909e9">YOCTON_PROP_OBJECT</a>) {</div>
<div class="line">      printf(<span class="stringliteral">&quot;property %s has subobject...\n&quot;</span>, <a class="code hl_function" href="yocton_8h.html#af58e01f89d1b2cacc998ee10c6422786">yocton_prop_name</a>(p));</div>
<div class="line">      print_obj(<a class="code hl_function" href="yocton_8h.html#a25b051fc6bd8836d5f37c25cbac0f753">yocton_prop_inner</a>(p));</div>
<div class="line">      printf(<span class="stringliteral">&quot;end of property %s.\n&quot;</span>, <a class="code hl_function" href="yocton_8h.html#af58e01f89d1b2cacc998ee10c6422786">yocton_prop_name</a>(p));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      printf(<span class="stringliteral">&quot;property %s has value %s\n&quot;</span>, <a class="code hl_function" href="yocton_8h.html#af58e01f89d1b2cacc998ee10c6422786">yocton_prop_name</a>(p),</div>
<div class="line">             <a class="code hl_function" href="yocton_8h.html#ae51150ada8b4ff73190a1c5c414ccf0e">yocton_prop_value</a>(p));</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="ayocton_8h_html_a25b051fc6bd8836d5f37c25cbac0f753"><div class="ttname"><a href="yocton_8h.html#a25b051fc6bd8836d5f37c25cbac0f753">yocton_prop_inner</a></div><div class="ttdeci">struct yocton_object * yocton_prop_inner(struct yocton_prop *property)</div><div class="ttdoc">Get the inner object associated with a yocton_prop of type YOCTON_PROP_OBJECT.</div></div>
<div class="ttc" id="ayocton_8h_html_ad4f38cb3e4a15df05cf64ebb0b18e763"><div class="ttname"><a href="yocton_8h.html#ad4f38cb3e4a15df05cf64ebb0b18e763">yocton_prop_type</a></div><div class="ttdeci">yocton_prop_type</div><div class="ttdoc">Type of a yocton_prop.</div><div class="ttdef"><b>Definition:</b> yocton.h:48</div></div>
<div class="ttc" id="ayocton_8h_html_ad4f38cb3e4a15df05cf64ebb0b18e763abbdd6efd548f5d6d02a6e7c9fdb909e9"><div class="ttname"><a href="yocton_8h.html#ad4f38cb3e4a15df05cf64ebb0b18e763abbdd6efd548f5d6d02a6e7c9fdb909e9">YOCTON_PROP_OBJECT</a></div><div class="ttdeci">@ YOCTON_PROP_OBJECT</div><div class="ttdoc">Property that has an object value.</div><div class="ttdef"><b>Definition:</b> yocton.h:59</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md0"></a>
The pull parsing model</h1>
<p >The APIs for many serialization formats are often document based, where data is deserialized into a document object that can then inspected (examples are the XML DOM, and protocol buffers). Yocton instead uses a <em>pull parser</em>. With a pull parser, it is up to the caller to read data one item at a time. This avoids the need for either autogenerated code (as with protobufs) or complicated APIs - Yocton's API is minimalist and simple to learn.</p>
<p >The API has been designed with a particular approach in mind to using input data to populate data structures. It is assumed that Yocton objects will correspond to C structs, and object properties will correspond to C struct fields. Here's a simple example of how a struct might be read and populated; the example struct here is a minimal one containing a single string field:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>foo {</div>
<div class="line">  <span class="keywordtype">char</span> *bar;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>foo *read_foo(<span class="keyword">struct</span> foo *f, <span class="keyword">struct</span> <a class="code hl_typedef" href="yocton_8h.html#a2d8d989503af56c34319ace5532748b6">yocton_object</a> *obj) {</div>
<div class="line">  <span class="keyword">struct </span><a class="code hl_typedef" href="yocton_8h.html#aa1688438ce1435782795c9f2a0008807">yocton_prop</a> *p;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span> ((p = <a class="code hl_function" href="yocton_8h.html#ac69750750bb48baa80600f3daf79447a">yocton_next_prop</a>(obj)) != NULL) {</div>
<div class="line">    <span class="keywordflow">if</span> (!strcmp(<a class="code hl_function" href="yocton_8h.html#af58e01f89d1b2cacc998ee10c6422786">yocton_prop_name</a>(p), <span class="stringliteral">&quot;bar&quot;</span>)) {</div>
<div class="line">      f-&gt;bar = <a class="code hl_function" href="yocton_8h.html#ad27b4cdfe5358267badf65179f7d52c4">yocton_prop_value_dup</a>(p);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="ttc" id="ayocton_8h_html_ad27b4cdfe5358267badf65179f7d52c4"><div class="ttname"><a href="yocton_8h.html#ad27b4cdfe5358267badf65179f7d52c4">yocton_prop_value_dup</a></div><div class="ttdeci">char * yocton_prop_value_dup(struct yocton_prop *property)</div><div class="ttdoc">Get newly-allocated copy of a property value.</div></div>
</div><!-- fragment --><p >While this is relatively easy to understand, it looks quite verbose. It is therefore important to note that there are convenience functions and macros to make things much simpler, as will be explained in the sections below.</p>
<p >Yocton is a recursive format where objects can also contain other objects. The assumption is that a subobject likely corresponds to a field with a struct type. Consider the following input:</p>
<div class="fragment"><div class="line">my_baz {</div>
<div class="line">  my_foo {</div>
<div class="line">    bar: &quot;hello world!&quot;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p >This might be used to populate structs of the following types:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>baz {</div>
<div class="line">  <span class="keyword">struct </span>foo *my_foo;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>qux {</div>
<div class="line">  <span class="keyword">struct </span>baz my_baz;</div>
<div class="line">};</div>
</div><!-- fragment --><p >When subobjects are mapped to struct types in this way, a function can be written to populate each type of struct. In the examples above, <code>read_foo()</code> might be complemented with <code>read_baz()</code> and <code>read_qux()</code> functions. This makes for clear and readable deserialization code; recursion in the programming language is used to handle recursion in the input file. The approach also means that the individual functions can be tested in isolation.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Reading properties and populating variables</h1>
<p >Yocton property values can contain arbitrary strings, the contents of which are open to interpretation. In practice though, the values are often likely to be one of several common base types which every C programmer is familiar with. There are convenience functions to help parse values into these types:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function   </th><th class="markdownTableHeadNone">Purpose    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="yocton_8h.html#a4b9aed0a4a53f37105797ddd6854a0d0" title="Parse the property value as a signed integer.">yocton_prop_int()</a>   </td><td class="markdownTableBodyNone">Parse value as a signed integer. Works with all integer types, performs bounds checking, etc.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="yocton_8h.html#a237f7d7cb6dfbb5fed45c4dc059a46bd" title="Parse the property value as an unsigned integer.">yocton_prop_uint()</a>   </td><td class="markdownTableBodyNone">Parse value as an unsigned integer. Works with all unsigned integer types, performs bounds checking, etc.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="yocton_8h.html#ad27b4cdfe5358267badf65179f7d52c4" title="Get newly-allocated copy of a property value.">yocton_prop_value_dup()</a>   </td><td class="markdownTableBodyNone">Returns the value as a plain, freshly allocated string, performing the appropriate checking for memory allocation failure. Useful for populating string fields.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="yocton_8h.html#aefc254d7127fded84698a6159ac4046a" title="Parse the property value as an enumeration.">yocton_prop_enum()</a>   </td><td class="markdownTableBodyNone">Parse value as an enum value by looking it up in an array of strings. Useful for representing values symbolically rather than just as raw integers.   </td></tr>
</table>
<p >While these functions are useful, in most cases it is more convenient to use the preprocessor macros which are specifically intended for populating variables (and struct fields).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Macro    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone"><a class="el" href="yocton_8h.html#a81d24bb35ddf399f7208be4bd2ac4fce" title="Set the value of a string variable if appropriate.">YOCTON_VAR_STRING()</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Signed integer   </td><td class="markdownTableBodyNone"><a class="el" href="yocton_8h.html#a725f13a3998a76ac25d7aac291b88fc7" title="Set the value of a signed integer variable if appropriate.">YOCTON_VAR_INT()</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unsigned integer   </td><td class="markdownTableBodyNone"><a class="el" href="yocton_8h.html#a04567fe0b000cfe9a0c8419f492125ec" title="Set the value of an unsigned integer variable if appropriate.">YOCTON_VAR_UINT()</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Enum   </td><td class="markdownTableBodyNone"><a class="el" href="yocton_8h.html#adbd8c3bf1b7d7f94fe1731e9174b6573" title="Set the value of an enum variable if appropriate.">YOCTON_VAR_ENUM()</a>   </td></tr>
</table>
<p >Consider the following input:</p>
<div class="fragment"><div class="line">signed_val: -123</div>
<div class="line">unsigned_val: 999</div>
<div class="line">string_val: &quot;hello world&quot;</div>
<div class="line">enum_val: THIRD</div>
</div><!-- fragment --><p >We might want to read this input and populate the following struct type:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> e { FIRST, SECOND, THIRD };</div>
<div class="line"><span class="keyword">struct </span>foo {</div>
<div class="line">  <span class="keywordtype">int</span> signed_value;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unsigned_value;</div>
<div class="line">  <span class="keywordtype">char</span> *string_value;</div>
<div class="line">  <span class="keyword">enum</span> e enum_value;</div>
<div class="line">};</div>
</div><!-- fragment --><p >In the following example, we populate a <code>struct foo</code> variable named <code>x</code>. A different <code>YOCTON_VAR_...</code> macro is used to match each property name and assign a value to a different struct field:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *enum_names[] = {<span class="stringliteral">&quot;FIRST&quot;</span>, <span class="stringliteral">&quot;SECOND&quot;</span>, <span class="stringliteral">&quot;THIRD&quot;</span>, NULL};</div>
<div class="line"><span class="keyword">struct </span>foo x = {0, 0, 0, NULL};</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_typedef" href="yocton_8h.html#aa1688438ce1435782795c9f2a0008807">yocton_prop</a> *p;</div>
<div class="line"><span class="keywordflow">while</span> ((p = <a class="code hl_function" href="yocton_8h.html#ac69750750bb48baa80600f3daf79447a">yocton_next_prop</a>(obj)) != NULL) {</div>
<div class="line">  <a class="code hl_define" href="yocton_8h.html#a725f13a3998a76ac25d7aac291b88fc7">YOCTON_VAR_INT</a>(p, <span class="stringliteral">&quot;signed_val&quot;</span>, <span class="keywordtype">int</span>, x.signed_value) ;</div>
<div class="line">  <a class="code hl_define" href="yocton_8h.html#a04567fe0b000cfe9a0c8419f492125ec">YOCTON_VAR_UINT</a>(p, <span class="stringliteral">&quot;unsigned_val&quot;</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, x.unsigned_value);</div>
<div class="line">  <a class="code hl_define" href="yocton_8h.html#a81d24bb35ddf399f7208be4bd2ac4fce">YOCTON_VAR_STRING</a>(p, <span class="stringliteral">&quot;string_val&quot;</span>, x.string_value);</div>
<div class="line">  <a class="code hl_define" href="yocton_8h.html#adbd8c3bf1b7d7f94fe1731e9174b6573">YOCTON_VAR_ENUM</a>(p, <span class="stringliteral">&quot;enum_val&quot;</span>, x.enum_value, enum_names);</div>
<div class="line">}</div>
<div class="ttc" id="ayocton_8h_html_a04567fe0b000cfe9a0c8419f492125ec"><div class="ttname"><a href="yocton_8h.html#a04567fe0b000cfe9a0c8419f492125ec">YOCTON_VAR_UINT</a></div><div class="ttdeci">#define YOCTON_VAR_UINT(property, propname, var_type, var)</div><div class="ttdoc">Set the value of an unsigned integer variable if appropriate.</div><div class="ttdef"><b>Definition:</b> yocton.h:527</div></div>
<div class="ttc" id="ayocton_8h_html_a725f13a3998a76ac25d7aac291b88fc7"><div class="ttname"><a href="yocton_8h.html#a725f13a3998a76ac25d7aac291b88fc7">YOCTON_VAR_INT</a></div><div class="ttdeci">#define YOCTON_VAR_INT(property, propname, var_type, var)</div><div class="ttdoc">Set the value of a signed integer variable if appropriate.</div><div class="ttdef"><b>Definition:</b> yocton.h:443</div></div>
<div class="ttc" id="ayocton_8h_html_a81d24bb35ddf399f7208be4bd2ac4fce"><div class="ttname"><a href="yocton_8h.html#a81d24bb35ddf399f7208be4bd2ac4fce">YOCTON_VAR_STRING</a></div><div class="ttdeci">#define YOCTON_VAR_STRING(property, propname, var)</div><div class="ttdoc">Set the value of a string variable if appropriate.</div><div class="ttdef"><b>Definition:</b> yocton.h:336</div></div>
<div class="ttc" id="ayocton_8h_html_adbd8c3bf1b7d7f94fe1731e9174b6573"><div class="ttname"><a href="yocton_8h.html#adbd8c3bf1b7d7f94fe1731e9174b6573">YOCTON_VAR_ENUM</a></div><div class="ttdeci">#define YOCTON_VAR_ENUM(property, propname, var, values)</div><div class="ttdoc">Set the value of an enum variable if appropriate.</div><div class="ttdef"><b>Definition:</b> yocton.h:613</div></div>
</div><!-- fragment --><p >In the above example the fields of a struct are being populated, but this does not have to be the case; for example the following sets an ordinary variable named <code>string_value</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *string_value = NULL;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_typedef" href="yocton_8h.html#aa1688438ce1435782795c9f2a0008807">yocton_prop</a> *p;</div>
<div class="line"><span class="keywordflow">while</span> ((p = <a class="code hl_function" href="yocton_8h.html#ac69750750bb48baa80600f3daf79447a">yocton_next_prop</a>(obj)) != NULL) {</div>
<div class="line">  <a class="code hl_define" href="yocton_8h.html#a81d24bb35ddf399f7208be4bd2ac4fce">YOCTON_VAR_STRING</a>(p, <span class="stringliteral">&quot;string_val&quot;</span>, string_value);</div>
<div class="line">}</div>
</div><!-- fragment --><p >It is important to note is that these macros are internally designed to provide a simple and convenient API, not for efficiency. If performance is essential or becomes a bottleneck, it may be preferable to avoid using these macros.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Pointer types</h1>
<p >Sometimes we might have a pointer variable, and want to initialize that variable when a particular property is read. For example, consider the following input:</p>
<div class="fragment"><div class="line">foo {</div>
<div class="line">  val: &quot;hello world&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p >We might want to use this to initialize the following pointer variable:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>foo {</div>
<div class="line">  <span class="keywordtype">char</span> *val;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>foo *my_foo = NULL;</div>
</div><!-- fragment --><p >In this scenario, we can use <code><a class="el" href="yocton_8h.html#ad43c0b69b6c9e92fab262f6a86934381" title="Allocate memory and set pointer variable if appropriate.">YOCTON_VAR_PTR()</a></code> to allocate a new <code>struct foo</code>. In the following example, when <code><a class="el" href="yocton_8h.html#ad43c0b69b6c9e92fab262f6a86934381" title="Allocate memory and set pointer variable if appropriate.">YOCTON_VAR_PTR()</a></code> matches a property named <code>foo</code>, a new <code>struct foo</code> is allocated, <code>my_foo</code> is initialized to point to it, and <code>parse_foo()</code> is called to populate it from the property's object value.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> parse_foo(<span class="keyword">struct</span> <a class="code hl_typedef" href="yocton_8h.html#a2d8d989503af56c34319ace5532748b6">yocton_object</a> *obj, <span class="keyword">struct</span> foo *my_foo);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_typedef" href="yocton_8h.html#aa1688438ce1435782795c9f2a0008807">yocton_prop</a> *p;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> ((p = <a class="code hl_function" href="yocton_8h.html#ac69750750bb48baa80600f3daf79447a">yocton_next_prop</a>(obj)) != NULL) {</div>
<div class="line">  <a class="code hl_define" href="yocton_8h.html#ad43c0b69b6c9e92fab262f6a86934381">YOCTON_VAR_PTR</a>(p, <span class="stringliteral">&quot;foo&quot;</span>, my_foo, {</div>
<div class="line">    parse_bar(<a class="code hl_function" href="yocton_8h.html#a25b051fc6bd8836d5f37c25cbac0f753">yocton_prop_inner</a>(p), my_foo);</div>
<div class="line">  });</div>
<div class="line">}</div>
<div class="ttc" id="ayocton_8h_html_ad43c0b69b6c9e92fab262f6a86934381"><div class="ttname"><a href="yocton_8h.html#ad43c0b69b6c9e92fab262f6a86934381">YOCTON_VAR_PTR</a></div><div class="ttdeci">#define YOCTON_VAR_PTR(property, propname, var, then)</div><div class="ttdoc">Allocate memory and set pointer variable if appropriate.</div><div class="ttdef"><b>Definition:</b> yocton.h:679</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md3"></a>
Constructing arrays</h1>
<p >The Yocton format has no special way of representing lists. Since property names do not have to be unique, it is simple enough to represent a list using multiple properties with the same name.</p>
<p >As with the previous example that described how to populate variables (and struct fields) with base types, convenience macros also exist for constructing arrays. The main difference is that an extra variable (or struct field) is needed to store the array length.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Macro    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">String array   </td><td class="markdownTableBodyNone"><a class="el" href="yocton_8h.html#a28750fce728f57862cd3c49ef18df187" title="Append value to a string array if appropriate.">YOCTON_VAR_STRING_ARRAY()</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Signed integer array   </td><td class="markdownTableBodyNone"><a class="el" href="yocton_8h.html#acd9cd470656f4efa8ae7b2d47145a30a" title="Append value to an array of signed integers if appropriate.">YOCTON_VAR_INT_ARRAY()</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unsigned integer array   </td><td class="markdownTableBodyNone"><a class="el" href="yocton_8h.html#aeaae39483f92a26dae863b58871f21a8" title="Append value to an array of unsigned integers if appropriate.">YOCTON_VAR_UINT_ARRAY()</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Enum array   </td><td class="markdownTableBodyNone"><a class="el" href="yocton_8h.html#acc990574763ffa638453661c2fa8a604" title="Append value to an array of enums if appropriate.">YOCTON_VAR_ENUM_ARRAY()</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Array of pointers   </td><td class="markdownTableBodyNone"><a class="el" href="yocton_8h.html#af8ed6fd64bfefb1a8a5db02fb04a7c79" title="Allocate memory and append pointer to it to an array if appropriate.">YOCTON_VAR_PTR_ARRAY()</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Array of structs   </td><td class="markdownTableBodyNone"><a class="el" href="yocton_8h.html#a73990a51d0313a83192872ab03c1a619" title="Match a particular property name and allocate array storage.">YOCTON_VAR_ARRAY()</a>   </td></tr>
</table>
<p >Consider the following input:</p>
<div class="fragment"><div class="line">signed_val: -123</div>
<div class="line">signed_val: 456</div>
<div class="line">unsigned_val: 999</div>
<div class="line">unsigned_val: 12345</div>
<div class="line">string_val: &quot;hello&quot;</div>
<div class="line">string_val: &quot;world&quot;</div>
<div class="line">enum_val: THIRD</div>
<div class="line">enum_val: FIRST</div>
</div><!-- fragment --><p >We might want to parse this input to populate the following struct type:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> e { FIRST, SECOND, THIRD };</div>
<div class="line"><span class="keyword">struct </span>bar {</div>
<div class="line">  <span class="keywordtype">int</span> *signed_values;</div>
<div class="line">  <span class="keywordtype">size_t</span> num_signed_values;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *unsigned_values;</div>
<div class="line">  <span class="keywordtype">size_t</span> num_unsigned_values;</div>
<div class="line">  <span class="keywordtype">char</span> **string_values;</div>
<div class="line">  <span class="keywordtype">size_t</span> num_string_values;</div>
<div class="line">  <span class="keyword">enum</span> e *enum_values;</div>
<div class="line">  <span class="keywordtype">size_t</span> num_enum_values;</div>
<div class="line">};</div>
</div><!-- fragment --><p >The following code populates a single <code>struct bar</code> named <code>x</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *enum_names[] = {<span class="stringliteral">&quot;FIRST&quot;</span>, <span class="stringliteral">&quot;SECOND&quot;</span>, <span class="stringliteral">&quot;THIRD&quot;</span>, NULL};</div>
<div class="line"><span class="keyword">struct </span>bar x = {NULL, 0, NULL, 0, NULL, 0, NULL, 0};</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_typedef" href="yocton_8h.html#aa1688438ce1435782795c9f2a0008807">yocton_prop</a> *p;</div>
<div class="line"><span class="keywordflow">while</span> ((p = <a class="code hl_function" href="yocton_8h.html#ac69750750bb48baa80600f3daf79447a">yocton_next_prop</a>(obj)) != NULL) {</div>
<div class="line">  <a class="code hl_define" href="yocton_8h.html#acd9cd470656f4efa8ae7b2d47145a30a">YOCTON_VAR_INT_ARRAY</a>(p, <span class="stringliteral">&quot;signed_val&quot;</span>, <span class="keywordtype">int</span>, x.signed_values,</div>
<div class="line">                       x.num_signed_values);</div>
<div class="line">  <a class="code hl_define" href="yocton_8h.html#aeaae39483f92a26dae863b58871f21a8">YOCTON_VAR_UINT_ARRAY</a>(p, <span class="stringliteral">&quot;unsigned_val&quot;</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>,</div>
<div class="line">                        x.unsigned_values, x.num_unsigned_values);</div>
<div class="line">  <a class="code hl_define" href="yocton_8h.html#a28750fce728f57862cd3c49ef18df187">YOCTON_VAR_STRING_ARRAY</a>(p, <span class="stringliteral">&quot;string_val&quot;</span>, x.string_values,</div>
<div class="line">                          x.num_string_values);</div>
<div class="line">  <a class="code hl_define" href="yocton_8h.html#acc990574763ffa638453661c2fa8a604">YOCTON_VAR_ENUM_ARRAY</a>(p, <span class="stringliteral">&quot;enum_val&quot;</span>, x.enum_values,</div>
<div class="line">                        x.num_enum_values, enum_names);</div>
<div class="line">}</div>
<div class="ttc" id="ayocton_8h_html_a28750fce728f57862cd3c49ef18df187"><div class="ttname"><a href="yocton_8h.html#a28750fce728f57862cd3c49ef18df187">YOCTON_VAR_STRING_ARRAY</a></div><div class="ttdeci">#define YOCTON_VAR_STRING_ARRAY(property, propname, var, len_var)</div><div class="ttdoc">Append value to a string array if appropriate.</div><div class="ttdef"><b>Definition:</b> yocton.h:364</div></div>
<div class="ttc" id="ayocton_8h_html_acc990574763ffa638453661c2fa8a604"><div class="ttname"><a href="yocton_8h.html#acc990574763ffa638453661c2fa8a604">YOCTON_VAR_ENUM_ARRAY</a></div><div class="ttdeci">#define YOCTON_VAR_ENUM_ARRAY(property, propname, var, len_var, values)</div><div class="ttdoc">Append value to an array of enums if appropriate.</div><div class="ttdef"><b>Definition:</b> yocton.h:643</div></div>
<div class="ttc" id="ayocton_8h_html_acd9cd470656f4efa8ae7b2d47145a30a"><div class="ttname"><a href="yocton_8h.html#acd9cd470656f4efa8ae7b2d47145a30a">YOCTON_VAR_INT_ARRAY</a></div><div class="ttdeci">#define YOCTON_VAR_INT_ARRAY(property, propname, var_type, var, len_var)</div><div class="ttdoc">Append value to an array of signed integers if appropriate.</div><div class="ttdef"><b>Definition:</b> yocton.h:473</div></div>
<div class="ttc" id="ayocton_8h_html_aeaae39483f92a26dae863b58871f21a8"><div class="ttname"><a href="yocton_8h.html#aeaae39483f92a26dae863b58871f21a8">YOCTON_VAR_UINT_ARRAY</a></div><div class="ttdeci">#define YOCTON_VAR_UINT_ARRAY(property, propname, var_type, var, len_var)</div><div class="ttdoc">Append value to an array of unsigned integers if appropriate.</div><div class="ttdef"><b>Definition:</b> yocton.h:557</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md4"></a>
Arrays of structs</h1>
<p >While the above macros are convenient for building arrays of base types, often it is preferable to construct arrays of structs. The <code><a class="el" href="yocton_8h.html#a73990a51d0313a83192872ab03c1a619" title="Match a particular property name and allocate array storage.">YOCTON_VAR_ARRAY()</a></code> macro can be used to do this (actually, it can be used to construct arrays of any type; it is what the previous macros were built upon). It does the following:</p>
<ol type="1">
<li>Check if the name of the property matches a particular name.</li>
<li>If the name matches, the array pointer is reallocated to allot space for a new element at the end of the array.</li>
<li>An arbitrary block of code is executed that can (optionally) populate the contents of the new array element.</li>
</ol>
<p >Consider the following input:</p>
<div class="fragment"><div class="line">item { val: 1 }</div>
<div class="line">item { val: 2 }</div>
<div class="line">item { val: 3 }</div>
</div><!-- fragment --><p >We might want to parse this input into the following array:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>foo {</div>
<div class="line">  <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>foo *items = NULL;</div>
<div class="line"><span class="keywordtype">int</span> num_items = 0;</div>
</div><!-- fragment --><p >In the following example, when <code><a class="el" href="yocton_8h.html#a73990a51d0313a83192872ab03c1a619" title="Match a particular property name and allocate array storage.">YOCTON_VAR_ARRAY()</a></code> matches a property named <code>item</code>, the <code>items</code> array is reallocated to allot space for a new element (<code>item[num_items]</code>). The <code>parse_foo()</code> function is then called to populate the contents of this new struct from the property's inner object value. Finally, the length of the array <code>num_items</code> is incremented.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> parse_foo(<span class="keyword">struct</span> <a class="code hl_typedef" href="yocton_8h.html#a2d8d989503af56c34319ace5532748b6">yocton_object</a> *obj, <span class="keyword">struct</span> foo *item);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_typedef" href="yocton_8h.html#aa1688438ce1435782795c9f2a0008807">yocton_prop</a> *p;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> ((p = <a class="code hl_function" href="yocton_8h.html#ac69750750bb48baa80600f3daf79447a">yocton_next_prop</a>(obj)) != NULL) {</div>
<div class="line">  <a class="code hl_define" href="yocton_8h.html#a73990a51d0313a83192872ab03c1a619">YOCTON_VAR_ARRAY</a>(p, <span class="stringliteral">&quot;item&quot;</span>, items, num_items, {</div>
<div class="line">    parse_foo(<a class="code hl_function" href="yocton_8h.html#a25b051fc6bd8836d5f37c25cbac0f753">yocton_prop_inner</a>(p), &amp;item[num_items]);</div>
<div class="line">    num_items++;</div>
<div class="line">  });</div>
<div class="line">}</div>
<div class="ttc" id="ayocton_8h_html_a73990a51d0313a83192872ab03c1a619"><div class="ttname"><a href="yocton_8h.html#a73990a51d0313a83192872ab03c1a619">YOCTON_VAR_ARRAY</a></div><div class="ttdeci">#define YOCTON_VAR_ARRAY(property, propname, var, len_var, then)</div><div class="ttdoc">Match a particular property name and allocate array storage.</div><div class="ttdef"><b>Definition:</b> yocton.h:302</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md5"></a>
Arrays of pointers</h1>
<p >The previous section covered how to construct an array of structs. The analogous <code><a class="el" href="yocton_8h.html#af8ed6fd64bfefb1a8a5db02fb04a7c79" title="Allocate memory and append pointer to it to an array if appropriate.">YOCTON_VAR_PTR_ARRAY()</a></code> can be used to construct an array of struct pointers. Consider the following input (same input as the previous section):</p>
<div class="fragment"><div class="line">item { val: 1 }</div>
<div class="line">item { val: 2 }</div>
<div class="line">item { val: 3 }</div>
</div><!-- fragment --><p >We might want to parse this input into the following array (note the difference to the previous section; this is an array of <em>pointers to</em> structs):</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>foo {</div>
<div class="line">  <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>foo **items = NULL;</div>
<div class="line"><span class="keywordtype">int</span> num_items = 0;</div>
</div><!-- fragment --><p >In the following example, when <code><a class="el" href="yocton_8h.html#af8ed6fd64bfefb1a8a5db02fb04a7c79" title="Allocate memory and append pointer to it to an array if appropriate.">YOCTON_VAR_PTR_ARRAY()</a></code> matches a property named <code>item</code>, a new <code>struct foo</code> is allocated and appended to the <code>items</code> array, and the <code>parse_foo()</code> function is called to populate the struct's contents from the property's inner object value. Finally, the length of the array <code>num_items</code> is incremented.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> parse_foo(<span class="keyword">struct</span> <a class="code hl_typedef" href="yocton_8h.html#a2d8d989503af56c34319ace5532748b6">yocton_object</a> *obj, <span class="keyword">struct</span> foo *item);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> ((p = <a class="code hl_function" href="yocton_8h.html#ac69750750bb48baa80600f3daf79447a">yocton_next_prop</a>(obj)) != NULL) {</div>
<div class="line">  <a class="code hl_define" href="yocton_8h.html#af8ed6fd64bfefb1a8a5db02fb04a7c79">YOCTON_VAR_PTR_ARRAY</a>(p, <span class="stringliteral">&quot;item&quot;</span>, items, num_items, {</div>
<div class="line">    parse_foo(<a class="code hl_function" href="yocton_8h.html#a25b051fc6bd8836d5f37c25cbac0f753">yocton_prop_inner</a>(p), items[num_items]);</div>
<div class="line">    num_items++;</div>
<div class="line">  });</div>
<div class="line">}</div>
<div class="ttc" id="ayocton_8h_html_af8ed6fd64bfefb1a8a5db02fb04a7c79"><div class="ttname"><a href="yocton_8h.html#af8ed6fd64bfefb1a8a5db02fb04a7c79">YOCTON_VAR_PTR_ARRAY</a></div><div class="ttdeci">#define YOCTON_VAR_PTR_ARRAY(property, propname, var, len_var, then)</div><div class="ttdoc">Allocate memory and append pointer to it to an array if appropriate.</div><div class="ttdef"><b>Definition:</b> yocton.h:720</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md6"></a>
Error handling</h1>
<p >There are many different types of error that can occur while parsing a Yocton file. For example:</p>
<ul>
<li>Syntax error</li>
<li>Memory allocation failure</li>
<li>Property has unexpected type (string for an object property, or vice versa)</li>
<li>Invalid property value (eg. overflow when parsing an integer value)</li>
<li>Violation of a user-provided constraint</li>
</ul>
<p >Continual checking for error conditions can make for complicated code. The Yocton API instead adopts an "error state" mechanism for error reporting. Write your code assuming success, and at the end, check once if an error occurred.</p>
<p >Here's how this works in practice: most parsing code involves continually calling <code><a class="el" href="yocton_8h.html#ac69750750bb48baa80600f3daf79447a" title="Read the next property of an object.">yocton_next_prop()</a></code> to read new properties from the file. If an error condition is reached, this function will stop returning any more properties. In effect it is like reaching the end of file. So when "end of file" is reached, simply check if an error occurred or whether the document was successfully parsed.</p>
<p >Here is a simple example of what this might look like:</p>
<div class="fragment"><div class="line"><span class="comment">// Returns true if file was successfully parsed:</span></div>
<div class="line"><span class="keywordtype">bool</span> parse_config_file(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keyword">struct</span> config_data *cfg)</div>
<div class="line">{</div>
<div class="line">  FILE *fs;</div>
<div class="line">  <span class="keyword">struct </span><a class="code hl_typedef" href="yocton_8h.html#a2d8d989503af56c34319ace5532748b6">yocton_object</a> *obj;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> *error_msg;</div>
<div class="line">  <span class="keywordtype">int</span> lineno;</div>
<div class="line">  <span class="keywordtype">bool</span> success;</div>
<div class="line"> </div>
<div class="line">  fs = fopen(filename, <span class="stringliteral">&quot;r&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (fs == NULL) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  obj = <a class="code hl_function" href="yocton_8h.html#a1c15d04cb8945c36d4dc16abbdd5b5f0">yocton_read_from</a>(fs);</div>
<div class="line">  parse_config_toplevel(obj, cfg);</div>
<div class="line"> </div>
<div class="line">  success = !<a class="code hl_function" href="yocton_8h.html#adb3fb5a96eae10dee13a7810273dbfd9">yocton_have_error</a>(obj, &amp;lineno, &amp;error_msg);</div>
<div class="line">  <span class="keywordflow">if</span> (!success) {</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Error in parsing config:\n%s:%d:%s\n&quot;</span>,</div>
<div class="line">            filename, lineno, error_msg);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="yocton_8h.html#a0a081a719afe45a3ba37c3eb3e6824c4">yocton_free</a>(obj);</div>
<div class="line">  fclose(fs);</div>
<div class="line">  <span class="keywordflow">return</span> success;</div>
<div class="line">}</div>
<div class="ttc" id="ayocton_8h_html_a0a081a719afe45a3ba37c3eb3e6824c4"><div class="ttname"><a href="yocton_8h.html#a0a081a719afe45a3ba37c3eb3e6824c4">yocton_free</a></div><div class="ttdeci">void yocton_free(struct yocton_object *obj)</div><div class="ttdoc">Free the top-level object and stop reading from the input stream.</div></div>
<div class="ttc" id="ayocton_8h_html_adb3fb5a96eae10dee13a7810273dbfd9"><div class="ttname"><a href="yocton_8h.html#adb3fb5a96eae10dee13a7810273dbfd9">yocton_have_error</a></div><div class="ttdeci">int yocton_have_error(struct yocton_object *obj, int *lineno, const char **error_msg)</div><div class="ttdoc">Query whether an error occurred during parsing.</div></div>
</div><!-- fragment --><p >Some of the API functions will also trigger the error state. It may be tempting to add extra checks in your code to avoid this happening, but it is better that you do not. If an error is triggered in this way, it is likely that it is due to an error in the file being parsed. Your API calls implicitly document the expected format of the input file. If the file does not conform to that format, it is the file that is wrong, not your code.</p>
<p >An example may be illustrative. Suppose your Yocton files contain a property called <code>name</code> which is expected to have a string value. If the property has an object value instead, a call to <code><a class="el" href="yocton_8h.html#ae51150ada8b4ff73190a1c5c414ccf0e" title="Get the string value of a yocton_prop of type YOCTON_PROP_STRING.">yocton_prop_value()</a></code> to get the expected string value will trigger the error state. That is not a misuse of the API; your code is implicitly indicating that a string was expected, and the input is therefore erroneous. The line number where the error occurred is logged, just the same as if the file itself was syntactically incorrect. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
